# Operador de propiedad opcional `?.`
`?` Valor opcional. Para que no dÃ© error cuando el dato con el que se opera es un *undefined*.
![[Drawing 2025-04-26 19.20.36.excalidraw|650]]
- ElÂ `?.`Â actÃºa como unÂ *"guardia de seguridad"*Â ğŸ›¡ï¸ al acceder aÂ `KONSTANTE[i]`.
- SiÂ `KONSTANTE[i]`Â **SÃ existe**Â (no esÂ `null`Â oÂ `undefined`), ejecutaÂ `toUpperCase()`. âœ…
- SiÂ `KONSTANTE[i]`Â **NO existe**, evita el error y devuelveÂ `undefined`. Entonces, el operadorÂ `||`Â *(OR lÃ³gico)* muestra el mensaje alternativo:Â `No existe ${i}`. 
![[Drawing 2025-04-24 10.07.13.excalidraw|650]]
Sustituye al operador Ternario. Que es algo mÃ¡s verboso.
# Variable
![[Pasted image 20250424103300.png|90]]
Es una variable privada

# Casting vs falso casting
A. Al emplear `(variable as string)` podemos emplear los mÃ©todos propios de un string, *sin pasarlo* a string.
B. Lo mismo pasa con `<string>variable`, que podemos emplearlo como string. Nos aparecerÃ¡n los mÃ©todos de los strings.
![[Drawing 2025-04-26 19.40.50.excalidraw|550]]
PodrÃ­amos decir que estas 2 formas, son un **"falso casteo"**.

Cuando hacemos un `String(variable)`, sÃ­ que estamos pasando la variable a string; mediando un casting explÃ­cito.
![[Pasted image 20250426200134.png]]
Hay que acordarse de que NO se puede *reasignar en bruto* el **tipo de dato** de una variable. TS NO ES JS!!!!! ni python.


Pese a que podemos tipar las variables que estamos utilizando en TS, en verdad podemos pasar de ello. Podemos emplear mÃ©todos que NO son propio s de un tipo de dato. Es por ello que decimos que el *Super-conjunto de TS* es **azÃºcar sintÃ¡ctico**.
# Enums
Enumeraciones. Sirve para trabajar con valores que estÃ©n dentro de un rango. SerÃ­a como un hibrido entre un Objeto y un Array. `enum`

![[Drawing 2025-04-24 14.18.43.excalidraw]]
hace una reasignaciÃ³n
![[Drawing 2025-04-24 14.33.56.excalidraw|250]]

El nombre de 

# Array asociativo
En la documentaciÃ³n de JS no existen. Pero en la prÃ¡ctica sÃ­ que las podemos crear. Aunque es cierto en en TS nos va a chillar.

```js
let arr = [];
arr["clave1"] = "valor1";
arr["clave2"] = "valor2";

console.log(arr.length); // 0
```
Un Array Asociativo va a tener par clave-valor



Un Array asociativo *no se puede recorrer con for...of*. Hay que hacerlo con **for...in**. Que es mÃ¡s tÃ­pico de los objetos. 

# For...in
Transforma las claves de un objeto, en este caso Array, en Strings.

# TypeScript
- [ ] TypeScript permite crear nuevos tipos (?) . 

cadena100, rockfm, los40, 

# Objeto
- `Object.keys(obj)`Â â†’ Devuelve unÂ **array de strings**Â con las *claves enumerables* del objeto.
- `obj.hasOwnProperty("clave")` para saber si existe o no esa clave en especÃ­fico, en un objeto. Esto lo podemos meter en un bucle **for...in** para recorrer todo el objeto. *Claves enumerables*
- `Object.getOwnPropertyNames(obj)` Nos da un array con todas las propiedades enumeradables *y NO enumerables* del objeto.
- `Reflect.ownKeys(obj)`Â â†’ DevuelveÂ **todas las claves**, incluyendo sÃ­mbolos

# Export - Import TS
Para que permita el export-import, hay que cambiar el `"module":commonjs` a `"module": "ES6"`

# Recorrer array asociativo
1. Creamos el array asociativo
	![[Pasted image 20250425070543.png]]
2. Obtenemos su nÃºmer claves, para saber con quÃ© rango tenemos que trabajar
	![[Pasted image 20250425070652.png]]
3. Metemos sus claves dentro de una variable, que es un Array
	![[Pasted image 20250425070752.png]]
4. Ya podemos iterar sobre ese Array que hemos generado atravÃ©s de las claves del anterior Array.
	![[Drawing 2025-04-25 07.09.56.excalidraw|500]]

# Diferencias entre CÃ³digo en FunciÃ³n Autoejecutada vs. CÃ³digo Global
La principal diferencia entre escribir cÃ³digo dentro de una funciÃ³n autoejecutada (IIFE) y escribirlo en el Ã¡mbito global afecta alÂ **alcance de las variables**Â y laÂ **persistencia de los datos**, pero no a la naturaleza de los datos mismos.
## 1. Alcance (Scope) de las Variables
### ğŸ”¹Â FunciÃ³n Autoejecutada (IIFE)
- Las variables declaradas conÂ `let`,Â `const`Â oÂ `var`Â dentro de la IIFE sonÂ **locales a esa funciÃ³n**.
- No contaminan el Ã¡mbito global.
- Se eliminan de memoria cuando la funciÃ³n termina (a menos que se creen closures).
### ğŸ”¹Â Ãmbito Global
- Las variables son accesibles desde cualquier parte del cÃ³digo.
- Permanecen en memoria mientras la pÃ¡gina estÃ© cargada.
- Riesgo de colisiones de nombres.
## 2. Persistencia de Datos
### ğŸ”¹Â Datos en IIFE
- Los datosÂ **no persisten**Â despuÃ©s de que la funciÃ³n termina, a menos que:
    - Se asignen a una variable global.
    - Se devuelvan y capturen externamente.
    - Se almacenen en el DOM, localStorage, etc.
### ğŸ”¹Â Datos en Ãmbito Global
- Los datosÂ **persisten**Â mientras la pÃ¡gina estÃ© cargada.
- Pueden ser modificados desde cualquier parte del cÃ³digo.