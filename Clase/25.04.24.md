# TypeScript
`tsc --init` Genera el archivo de configuración llamado *tsconfig.json*. 
`tsc archivo` para transpilar a JavaScript ese archivo. Esto va a pasar todos los *let* y *const* como *var*. Esto es para que todos los navegadores puedan leer el código.
`tsc` Compilar el proyecto completo, de forma manual.
`tsc -w` o `tsc --watch` que transpile automáticamente cada vez que se guardan cambios

## String
`?` Valor opcional. Para que no dé error cuando el dato con el que se opera es un *undefined*.
![[Drawing 2025-04-24 10.07.13.excalidraw]]

![[Pasted image 20250424103300.png|90]]
Es una variable privada

## Casting vs NoCasting
Cuando hacemos un `String(variable)`, sí que estamos pasando la variable a string; mediando un casting explícito.

Al emplear `(variable as string)` podemos emplear los métodos propios de un string, *sin pasarlo* a string.
Lo mismo pasa con `<string>variable`, que podemos emplearlo como string. Nos aparecerán los métodos de los strings.
Podríamos decir que estas 2 formas, son un **"falso casteo"**.

Hay que acordarse de que NO se puede *reasignar en bruto* el tipo de dato de una variable. TS NO ES JS!!!!! ni python.

# Consejos
Pese a que vamos a estar estudiando TypeScript y Angular. Lo que tenemos que tener grabado a fuego, son los fundamos de JavaScript. Pues todo va a estar basado en JS. Con ello bien afianzado, codremos comenzar a construir. 

Debemos saber qué cosas se pueden hacer o no en JS en el año que estamos trabajando. Ya que hay cosas que sí otras que no se pueden hacer en esas versiones. Ej: si empleamos *Angular* de un año en concreto, tenemos que saber 

# Tareas 
## Buscar:
- Python + **Reflex**  -->  Frontend
- Streamlink : También hace webs con Python
- Cómo se comunica un servidor con un cliente. Cómo funciona en envío de un sitio web. Como hace JS que se pueda repartir el peso de la aplicación para que no pese tanto en el servidor, y encargarla esa tarea a la máquina del cliente.
- Tengo un archivo de TS que hace (código fuera de la función). Tengo otro archivo TS (código dentro de una función). Que esplique la diferencia entre ambas. Que dé una batería de ejemplos con respecto a ello para explicarlo.
- Cómo se hace correctamente un *export-import* en TS? 
- Cómo se puede hacer un `for()` en un *Array asociativo* si tiene logitud **0**.
- - Existen más formas de saber qué claves tiene un objeto?
## Repasar:
- Desestructuración dentro de función flecha.
- PDF de curso.
# TypeScript
Pese a que podemos tipar las variables que estamos utilizando en TS, en verdad podemos pasar de ello. Podemos emplear métodos que NO son propio s de un tipo de dato. Es por ello que decimos que el *Super-conjunto de TS* es **azúcar sintáctico**.
## Enums
Enumeraciones. Sirve para trabajar con valores que estén dentro de un rango. Sería como un hibrido entre un Objeto y un Array. `enum`

![[Drawing 2025-04-24 14.18.43.excalidraw]]
hace una reasignación
![[Drawing 2025-04-24 14.33.56.excalidraw|250]]

El nombre de 

## Array asociativo
En la documentación de JS no existen. Pero en la práctica sí que las podemos crear. Aunque es cierto en en TS nos va a chillar.

Un Array Asociativo va a tener par clave-valor

Un Array asociativo *no se puede recorrer con for...of*. Hay que hacerlo con **for...in**. Que es más típico de los objetos. 

### For...in
Transforma las claves de un objeto, en este caso Array, en Strings.

# TypeScript
TypeScript permite crear nuevos tipos (?) . 

cadena100, rockfm, los40, 

# Objeto
`obj.hasOwnProperty("clave")` para saber si existe o no esa clave en específico, en un objeto.
